### SemVer Reading Reflection

Semantic versioning is essentially a set of rules / guidelines in order to prevent ‘dependency hell’. It’s something all developers want to avoid–a situation that makes it extremely difficult to move the project forward via updates due to version lock and/or version promiscuity. A lot of the SemVer rules are closely related to version numbers. It is formatted in a very specific way: major.minor.patch. Some key rules in SemVer are how major, minor, and patch are incremented. Incrementing the patch means that bug fixes that didn’t affect the API occurred. Incrementing the minor version means that there were backwards compatible API changes. Incrementing the major means that there were backward incompatible API changes. Some other key takeaways from semantic versioning is that it must declare a public API that is both precise and comprehensive. 

So, why exactly do we use semantic versioning? There are a couple of reasons– primarily because it makes everything a lot more organized. Having clear and universal guidelines makes collaborating easier, as it can help other developers who might be using your code as a dependency. 

Semantic versioning is used across all programming languages. Developers have even started to create new features in languages to accommodate for semantic versioning. An example of this is the ‘twiddle-wakka’. Commonly used in Ruby, it ensures that your software is dependent on future versions of a dependency– but only if they’ve gone through minor changes. For example, “gem 'example',  '~> 2.4” means that the highest version of the gemfile ‘example’ will be between 2.4 and 3. Twiddle-wakkas essentially encourages developers to use semantic versioning, which also leads to more effective code being written overall. 
